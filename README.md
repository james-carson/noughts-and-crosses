# noughts-and-crosses

Welcome to the first README I have written during this course! From now, I will try to do this for each project that I complete in order to better reflect and learn.

I found this project surprisingly frustrating. The instructions suggested that the best way to approach the project was to create the logic for a console-based game, get that working, and then add the UI and tweak the logic.

I didn't find this approach to be useful. It meant that I essentially approached this as two almost separate projects. Creating the console game was relatively simple; I created the logic for creating a virtual gameboard and setting up the players, which was easy. I set up the gameboard as a 3x3 array of arrays with blank cells, gave them an index number and a value (initially blank), and then used prompts to populate the player objects.

I then encountered problems when checking for a win. I decided that the best way to do this would be to work out the winning combinations, of which there are 8, add them into an array, then iterate over these combinations checking the existing cells for X's and O's. All well and good, but I could not get it to work. After a while, I realised that my method of checking for a win would work perfectly well with a 1D array, but I have created a 2D array, which explained why the function crashed on the 4th round of iteration. I weighed up whether to change the checkWin function or the layout of the gameboard, and decided that there wasn't really any benefit to havign a 2D gameboard, so changed that.

I had my console game working perfectly well. Now, to create a UI and assign the logic to it. I decided that the grid should be made of buttons and that the player information should go either side of it. I wanted a text display underneath the board that updated whenever anything happened, deciding to have two divs in a grid, with the bigger and lower of the two displaying the current message and the upper displaying the previous. 

I decided that I would obtain the player information with this text display. This turned out to be much more difficult than first imagined and I could not get it working properly, so I temporarily went back to using prompts. The issue was that the way that the JS was setup meant that the game tried to get all of the player information at once as it was in the same function. I did some research and ended up using ChatGPT (more on that later) which told me how to use setTimeout() to delay each and allow the text display to flow more naturally. I decided that although prompts did not look particularly good, they were effective in getting the information I needed, so I used a combination of these and setTimeout() to obtain the information and display it. So far so good.

I tried to start the game using a click on the text display to start the game, but this proved surprisingly problematic. I eventually abandoned this (as with other features) as it was causing more harm than good. Setting up the game logic to listen for clicks and updating the gameboard was simple enough, and before long I had everything working, after a quick tweak of checkFull() (changing 'undefined' to '') 

As usual, I played the game a bit (I believe it's called testing...) and something went wrong: The game ended prematurely. A quick investigation showed me that I had entered a winning combination incorrectly. Easily fixed and lucky that I had entered the turns that way or I may not have noticed.

After this, everything was put together, ready to be pushed, after a final test. Not working. Wins were not being declared. After tearing my hair out for a while and doing some debugging, I had to turn to ChatGPT. It told me that the timeouts meant that the turns weren't being logged in time for the checkWin() (or something like this, it was yesterday...), which left me two options: scrap the timeouts and have my display not look as nice, or rewrite everything to let them work. I went for functionality over beauty (this part is the JS course, after all), got rid of the timeouts and had all the player data populated at once. I spruced everything up again, and the finished product is what you see now.

What have I learned? Firstly, that I have a tendency to overcomplicate things without realising. Looking at others' projects, many don't have a player name and they don't get to choose a symbol. Why did I decide to work this in? I don't know, it just came naturally. In the planning phase, I need to consider each aspect in more detail to work out whether I really need it or not. Another example is using the UI to get the user data. Why this way? Why did I decide prompts weren't enough? I still don't like the prompts as they don't look good, but I saw another game that had a user entry screen first, which then changed into a gameboard. I think that in the future it might be worth thinking about using different 'screens' or 'levels', which would help me to achieve what I want.

Secondly, I need to plan better. I have become worse at that as the course has gone on. I drew up my UI in my notebook and made a list of some functions I might need, but that's it. I am becoming too reliant on ploughing ahead and doing research rather than stepping back and using my notebook and my head to think things through. I also need to ensure I have the bigger picture in my head at all times, rather than separating the seen and the unseen into two loosely connected mini-projects. I will improve on this.

Thirdly, it's not really something I have learned, but I am conflicted about using ChatGPT. At times, I have found it extremely helpful, but at times I lean too much on it rather than going through my own code or debugging. Here are my two stances:

On the for side, I have read many times during this course that it's not necessary or even possible to remember every little detail and a key skill is to learn how to look for information. How different is using ChatGPT different from using Google or Stack Overflow? I would say a bit, but it's important to understand how Chat GPT works. It's not 'thinking' for you, it's using an enormous amount of data in order to put the next most-likely word or bit of code after the last. It gets things wrong - so do other sources on the internet. In this way, I see it as a bit of a shortcut to getting the precise information you want.

On the against side, it's too easy. Doing a self-taught(ish) course on your own is tough when you can't ask anyone any questions. There is a Discord, but I haven't used it much, despite how helpful people are, I just want the answers NOW. Chat GPT finds them the quickest. However, it's TOO easy. Often I set up a new chat when I start a project and tell it who I am, what I am doing, what I may need help with etc, and explicitly ask it to not provide code to me unless I clearly request it. Usually, it complies for a while, and then eventually just starts giving you code anyway. When you've been coding for 4 hours, you're tired and frustrated, and the code is just there, it can be too tempting to just copy and paste.

Going back to my previous career, what would I have advised my students? Probably, balance. There are times when it's fine for me to use ChatGPT and times when I shouldn't. I think that as long as I have planned things our correctly, I have done my own research, I have Googled what I need to, and have done my own debugging, it's fine to ask for help (but usually not code - this should be a last resort). I need to ensure that I am training my brain to think like a developer and not just taking the easy way out.

Finally, I need to get better at design. My UI is fine, but that's it, it's fine. I am not the most visually creative, so I need to learn how to be for this to work long-term. Perhaps taking a course at the end of this course would be a good idea. If anyone actually reads this and knows a good one, let me know!

Those are my reflections on this project and the this is the end of my first README. If anyone has read this far - congratulations! I'll buy you a beer. But really this is more of a reflective process to try and make sure I do better next time. I am happy with my progress, slow as it is, and I am determined to finish this course.